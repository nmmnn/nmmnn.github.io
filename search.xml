<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 分离式编译</title>
      <link href="/2022/04/27/C++/%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91/"/>
      <url>/2022/04/27/C++/%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是百度百科对<a href="https://baike.baidu.com/item/%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F/18692138">分离式编译的介绍</a></p></blockquote><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>​    一个程序（项目）由若干个<strong>源文件</strong>共同实现，而每个源文件单独编译生成<strong>目标文件</strong>，最后将所有目标文件连接起来形成单一的<strong>可执行文件</strong>的过程。</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h2><p>​    涉及到不同模块（源文件）定义的函数和变量之间相互调用的问题，C++采用的方法是：<code>只要给出函数原型（或外部变量声明，注意是声明），就可以在本源文件中使用该函数（变量）。每个源文件都是独立的编译单元，在当前源文件中使用但未在此定义的函数或变量，就假设在其他源文件中定义好了。每个源文件生成独立的目标文件(obj文件)，然后通过连接将目标文件组成最终的可执行文件。</code></p><h2 id="3-要点"><a href="#3-要点" class="headerlink" title="3. 要点"></a>3. 要点</h2><ol><li><p>函数或者外部变量<strong>一次定义，多次声明</strong>。</p></li><li><p>函数<strong>声明</strong>有作用域：类的成员函数只能在类内声明，外部函数如果在本源文件中的一个函数内声明，则该外部函数声明的作用域只在函数内部，若在其他函数中需要使用该外部函数，还需要重新声明。</p></li><li><p>函数可以只被声明而不定义，只要没发生函数调用，编译链接不会出错。例如一个类可以在两个源文件中分离实现其成员函数。</p></li><li><p>由分离编译模式也可以得到<strong>头文件</strong>的书写规范。头文件的目的是提供其他源文件中定义的，可以被当前源文件使用的内容（函数、变量等）的<code>声明</code>。因此，有个基本的假设是：头文件要被多次被不同的源文件包含。<code>因此，一般都不在头文件中定义函数、定义外部变量，因为这样的头文件只能被包含一次，没有被包含第二次的可能性，背离了设立头文件的初衷。</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 分离式编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 变量与基本类型</title>
      <link href="/2022/04/26/C++/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/04/26/C++/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-内置基本类型"><a href="#2-1-内置基本类型" class="headerlink" title="2.1 内置基本类型"></a>2.1 内置基本类型</h1><p>包括 <strong>算术类型(整型、浮点型、字符型、布尔型)</strong> 和 <strong>空类型(void)</strong> </p><h2 id="2-1-1-算数类型"><a href="#2-1-1-算数类型" class="headerlink" title="2.1.1 算数类型"></a>2.1.1 算数类型</h2><ol><li><p>算术类型分为 <strong>整型</strong>（包括整形、字符和布尔类型在内）和 <strong>浮点型</strong>。</p></li><li><p>关于如何选择类型：</p><ul><li>不可能为为负时选用无符号类型</li><li>Int 执行整数运算，数值超过 int 范围用 long long</li><li>用 double 执行浮点运算，因为 float 通常精度不够且与 double 的计算代价相差无几</li></ul></li><li><p><strong>注意</strong>：带符号类型与无符号类型一起出现在表达式里时，带符号类型会自动转换为无符号类型。</p></li></ol><h1 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h1><h2 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h2><ol><li>基本形式：<strong>类型说明符</strong> 变量名1，变量名2，~ 变量名n；还可以为变量赋初值。</li><li><strong>对象</strong>：一块能存储数据并具有某种类型的内存空间。</li><li><strong>初始化 与 赋值</strong>：初始化是创建变量时赋予其一个初始值，而赋值是把对象的当前值擦除，用一个新值代替。</li><li><strong>注意</strong>：<code>函数体内</code> 的 <code>内置类型</code> 将不被默认初始化，类对象没有显式初始化，其值由类决定。</li></ol><h2 id="2-2-2-变量声明与定义"><a href="#2-2-2-变量声明与定义" class="headerlink" title="2.2.2 变量声明与定义"></a>2.2.2 变量声明与定义</h2><ul><li>为了支持<a href="https://baike.baidu.com/item/%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F/18692138"><strong>分离式编译</strong></a>，C++将<code>声明</code>与<code>定义</code>区分。<strong>声明</strong>使得名字为程序所知（一个文件想使用别的文件定义的名字就必须包含对该名字的声明）；而<strong>定义</strong>负责创建与名字关联的实体。</li><li>用法：声明一个变量而不定义它，在变量名前加 <code>extern</code>，而且不要<strong>显式</strong>初始化变量（会抵消，相当于定义）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">// 定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">// 定义k</span></span><br></pre></td></tr></table></figure><ul><li>注意：<em><strong>变量能且只能被定义一次，但是可以被多次声明</strong></em>。</li></ul><h1 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h1><ul><li><p>基于其他类型定义的类型叫做复合类型：本文介绍<strong>引用</strong>和<strong>指针</strong>。</p></li><li><p>变量声明语句：<strong>基本数据类型</strong> <strong>声明符列表</strong> 。复合类型的声明符不仅包含变量名。</p></li></ul><h2 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h2><ol><li>声明符：&amp;d 其中d是变量名。</li><li>引用不是<strong>对象</strong>，是为已存在的对象起的一个名字。初始化变量时，初始值会被拷贝到新建的对象中，而定义引用时，程序将引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用变量。因此<strong>不能定义引用的引用</strong>。</li><li>一旦初始化完成，引用将一直与它的初值对象绑定在一起，无法绑定到另一个对象上，因此<strong>引用必须初始化</strong>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i; <span class="comment">// r绑定到变量i上</span></span><br><span class="line">r = <span class="number">1</span>;    <span class="comment">// 修改r的值就是修改i的值</span></span><br></pre></td></tr></table></figure><h2 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h2><ol><li>声明符：*d 其中d是变量名。</li><li>指针与引用的异同：<ul><li>共同点：指针与引用都实现了对其他对象的间接访问。</li><li>不同：<ol><li>指针是对象，存了其他变量的地址，可以对指针进行赋值和拷贝，可以指向几个不同的对象。</li><li>引用必须初始化，而指针无需在定义时初始化（未初始化时有不确定的值）。</li></ol></li></ul></li><li>引用不是对象，因此<strong>不能定义指向引用的指针</strong>。</li><li>空指针：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">// 推荐方式，nullptr是一种特殊类型的字面值，可以转换为任意的指针类型</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p4 = i; <span class="comment">// 错误，不能把int变量赋值给指针，即使值是0</span></span><br></pre></td></tr></table></figure><h2 id="2-3-3-指向指针的指针与指向指针的引用"><a href="#2-3-3-指向指针的指针与指向指针的引用" class="headerlink" title="2.3.3 指向指针的指针与指向指针的引用"></a>2.3.3 指向指针的指针与指向指针的引用</h2><ul><li><p>指向指针的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">int</span> **pp = &amp;p; <span class="comment">// 指向指针的指针</span></span><br></pre></td></tr></table></figure></li><li><p>指向指针的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// 从右向左读：&amp;表示r是一个引用，声明符其他部分确定r引用的类型：*表示r引用的是一个int指针</span></span><br></pre></td></tr></table></figure></li><li><p>更复杂的声明：<strong>涉及到数组时从括号内向外、自左向右读</strong></p><ol><li>指针数组<code>int *p[10];</code></li><li>指向数组的指针<code>int (*p)[10] = &amp;arr;</code></li><li>指向数组的引用<code>int (&amp;r)[10] = &amp;arr;</code></li><li>指向指针数组的引用 <code>int *(&amp;r)[10] = arr;</code><strong>读法是</strong>：r是一个引用，引用的对象是一个数组，数组里面保存的是int指针类型。</li></ol></li></ul><h1 id="2-4-const-限定符"><a href="#2-4-const-限定符" class="headerlink" title="2.4 const 限定符"></a>2.4 const 限定符</h1><ul><li>const 对象默认情况下只在本文件有效，如果要在多个文件之间共享 const 对象，那么需要在 <strong>定义 和 声明 前都加extern关键字</strong>。</li></ul><h2 id="2-4-1-const-与-引用"><a href="#2-4-1-const-与-引用" class="headerlink" title="2.4.1 const 与 引用"></a>2.4.1 const 与 引用</h2><ol><li><p><strong>对 const 对象（const int i &#x3D; 1;）的引用必须是 const 引用（const int &amp;）</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp; r = i; <span class="comment">// 错，对int常量的引用必须是const int &amp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; cr = i; <span class="comment">// 对</span></span><br></pre></td></tr></table></figure></li><li><p><strong>const type &amp;不一定绑定到const 对象，可以是非常量对象、字面值，甚至是一个表达式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; cr = i; <span class="comment">// 对，const in &amp;可以绑定到常量，但是不能通过cr改变i的值</span></span><br><span class="line">cr = <span class="number">2</span>; <span class="comment">// 错，不能通过常量引用改变对象值</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-4-2-const-与-指针"><a href="#2-4-2-const-与-指针" class="headerlink" title="2.4.2  const 与 指针"></a>2.4.2  const 与 指针</h2><ol><li><p><em><em>指向常量的指针<code>必须是</code>：const type * cptr，但是 const type <em>ptr 不一定要指向常量</em></em> ，</em>*cptr 不能用来改变所指向对象的值，但是指针变量（注意是变量）cptr自己的值是可以改变的，也即 cptr可以指向不同的对象**。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;ci; <span class="comment">// 错</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cptr = &amp;ci; <span class="comment">// 对</span></span><br><span class="line">*cptr = <span class="number">2</span>; <span class="comment">// 错，不能用来改变所指向对象的值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">cptr = &amp;i; <span class="comment">// 对，指向常量的指针可以指向变量，而且可以在生命期内前后指向不通的对象</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量指针：type * const cptr &#x3D; &amp;ci，把const放在标识符前强调指针本身是常量，必须初始化</strong>。<strong>常量指针只能指向一个对象（地址），但是指向的对象可以是常量也可以是变量：指向变量时，是可以通过指针改变对象的值的；指向常量时，由上一条可知必须是 const type * const ccptr &#x3D; &amp;ci，既不能改变指针自己的值（指向别的对象），也不能通过指针改变所指向的对象（常量）的值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> cptr = &amp;i; <span class="comment">// 对，常量指针可以指向变量</span></span><br><span class="line">cptr = &amp;ci; <span class="comment">// 错，不能前后指向不同的对象</span></span><br><span class="line">cptr = <span class="number">3</span>; <span class="comment">// 对，常量指针指向变量的时候可以通过指针改变变量的值</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> cptr2 = &amp;ci; <span class="comment">// 错，cptr2不是指向常量的指针（cosnt type *）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> ccptr = &amp;ci; <span class="comment">// 对，ccptr是一个指向常量的常量指针，既不能改变自己的值，也不能改变指向的常量的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<strong>指向常量的指针或者引用</strong>（const type &amp;，const type *），仅仅只是指针或引用“自己”认为指向了常量，因此自觉的不允许改变所指向的对象的值。</p></li></ol><h1 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h1><h2 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h2><ul><li><p><strong>typedef 关键字</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base = int, p = int *</span></span><br></pre></td></tr></table></figure></li><li><p><strong>using 别名声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> wages = <span class="type">int</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意：</strong> 下面这个例子中，ChPTR是指向char的指针，而const是对指定类型的修饰，实际上 const chPTR 中 const 修饰的是<strong>指针</strong>，而不是char。const char * cstr中，const修饰的是char。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * ChPTR;</span><br><span class="line"><span class="type">const</span> ChPTR cstr = <span class="number">0</span>; <span class="comment">// cstr是指向char的常量指针，等价于 char * const cstr = 0 </span></span><br><span class="line"><span class="type">const</span> ChPTR * pp; <span class="comment">// pp是一个指针，指向 const ChPTR 类型的对象，也就是指向一个(指向char的常量指针)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-5-2-auto"><a href="#2-5-2-auto" class="headerlink" title="2.5.2 auto"></a>2.5.2 auto</h2><ul><li>需要初值</li><li>忽略顶层const，保留底层const</li></ul><h2 id="2-5-3-decltype"><a href="#2-5-3-decltype" class="headerlink" title="2.5.3 decltype"></a>2.5.3 decltype</h2>]]></content>
      
      
      <categories>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++ Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2022/04/22/Hexo/Learn%20Hexo/"/>
      <url>/2022/04/22/Hexo/Learn%20Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题-ctr-1"><a href="#一级标题-ctr-1" class="headerlink" title="一级标题 ctr+1"></a>一级标题 ctr+1</h1><h2 id="二级标题-ctr-2"><a href="#二级标题-ctr-2" class="headerlink" title="二级标题 ctr+2"></a>二级标题 ctr+2</h2><h3 id="三级标题-ctr-3"><a href="#三级标题-ctr-3" class="headerlink" title="三级标题  ctr+3"></a>三级标题  ctr+3</h3><ul><li>无序列表 * + 空格</li><li>无序列表 - + 空格</li><li>无序列表 + + 空格</li></ul><ol><li>有序列表 数字 + .</li><li>有序列表</li></ol><blockquote><p>区块引用  &gt;</p></blockquote><blockquote><blockquote><p>引用嵌套 &gt;&gt;</p></blockquote></blockquote><blockquote><ol><li>引用中使用有序列表 &gt; 1.</li><li>引用中使用有序列表 &gt; 2.</li></ol><ul><li>引用中使用无序列表 &gt; * (接* - +都一样)</li></ul></blockquote><p><code>代码行 `` ，也可以当成强调？</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码块：``` 语言类型 然后回车</span><br><span class="line">链接：[链接名](链接地址) 或者 &lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名</a> </p><p>&lt;链接地址&gt;</p><p><strong>加粗用两个</strong>**</p><p><em>斜体用一个*</em></p><p><em><strong>斜体且加粗用三个*</strong></em></p><p>** 转义特殊字符*用\ **</p><p>$f(x) &#x3D; sin(x)$</p><blockquote><p>图片要用相对路径：![说明](..&#x2F;..&#x2F;imgs&#x2F;xxx.jpg)</p></blockquote><p><img src="/../../imgs/index1.jpg" alt="img"></p><p>表格：用 |表头|表头|</p><table><thead><tr><th>表头一</th><th>表头二</th><th>表头三</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">快标签用法：</span><br><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note simple"><p>默认 提示块标籤</p></div><div class="note default simple"><p>default 提示块标籤</p></div><div class="note primary simple"><p>primary 提示块标籤</p></div><div class="note success simple"><p>success 提示块标籤</p></div><div class="note info simple"><p>info 提示块标籤</p></div><div class="note warning simple"><p>warning 提示块标籤</p></div><div class="note danger simple"><p>danger 提示块标籤</p></div>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/21/hello-world/"/>
      <url>/2022/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
